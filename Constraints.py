from Delenox_Config import lattice_dimensions, value_range
import numpy as np
from Visualization import voxel_plot

materials = {'External_Space': 0, 'Interior_Space': 1, 'Wall': 2, 'Floor': 3, 'Roof': 4}

class InfeasibleError(Exception):
    pass

def apply_constraints(lattice):
    """
    Take the lattice generated by a CPPN-NEAT genome and apply the set of constraints implemented in
    the pipeline.
    :param lattice: Input lattice generated by CPPN-NEAT genome.
    :return: Adjusted lattice resulting from constraint functions.
    """
    try:
        lattice = iterative_flood(lattice)
        lattice = identify_materials(lattice)
        metrics = assess_quality(lattice)
        return True, lattice, metrics
    except InfeasibleError:
        return False, lattice, []

def bounding_box(lattice):
    """
    :param lattice:
    returns:
    """
    left_bound = 20
    right_bound = 0
    near_bound = 20
    far_bound = 0
    bottom_bound = 0
    top_bound = 0
    for (x,y,z) in value_range:
        if lattice[x][y][z] > 1:
            if y > far_bound:
                far_bound = y
            elif y < near_bound:
                near_bound = y
            if x > right_bound:
                right_bound = x
            elif x < left_bound:
                left_bound = x
            if z > top_bound:
                top_bound = z
    return (left_bound, right_bound), (near_bound, far_bound), (bottom_bound, top_bound)

def footprint_ratios(lattice, horizontal_bounds, vertical_bounds, depth_bounds):
    top_half = 0
    bottom_half = 0
    left_half = 0
    right_half = 0
    near_half = 0
    far_half = 0
    middle_x = 0
    outside_x = 0
    middle_y = 0
    outside_y = 0
    middle_z = 0
    outside_z = 0

    width = horizontal_bounds[1] - horizontal_bounds[0]
    depth = depth_bounds[1] - depth_bounds[0]
    height = vertical_bounds[1]

    for x in range(horizontal_bounds[0], horizontal_bounds[1] + 1):
        for y in range(depth_bounds[0], depth_bounds[1] + 1):
            for z in range(vertical_bounds[0], vertical_bounds[1] + 1):
                if lattice[x][y][z] > 1:
                    if horizontal_bounds[0] + width / 4 < x < horizontal_bounds[1] - width / 4:
                        middle_x += 1
                    else:
                        outside_x += 1
                    if depth_bounds[0] + depth / 4 < y < depth_bounds[1] - depth / 4:
                        middle_y += 1
                    else:
                        outside_y += 1
                    if height / 4 < z < vertical_bounds[1] - height / 4:
                        middle_z += 1
                    else:
                        outside_z += 1
                    if x < horizontal_bounds[0] + width / 2:
                        left_half += 1
                    else:
                        right_half += 1
                    if y < depth_bounds[0] + depth / 2:
                        bottom_half += 1
                    else:
                        top_half += 1
                    if z < height / 2:
                        near_half += 1
                    else:
                        far_half += 1
    return [left_half / right_half, top_half / bottom_half, near_half / far_half, middle_x / outside_x, middle_y / outside_y, middle_z / outside_z]

def height_symmetry(lattice, horizontal_bounds, vertical_bounds, depth_bounds):
    symmetry_count = 0
    for x in range(horizontal_bounds[0], horizontal_bounds[1] + 1):
        for y in range(depth_bounds[0], depth_bounds[1] + 1):
            for z in range(vertical_bounds[0], int(vertical_bounds[1] / 2) + 1):
                if lattice[x][y][z] > 1 and lattice[x][y][int(vertical_bounds[1] / 2) + z] > 1:
                    symmetry_count += 1
    return symmetry_count

def width_symmetry(lattice, horizontal_bounds, vertical_bounds, depth_bounds):
    symmetry_count = 0
    width = horizontal_bounds[1] - horizontal_bounds[0]
    for x in range(horizontal_bounds[0], int(horizontal_bounds[1] / 2) + 1):
        for y in range(depth_bounds[0], depth_bounds[1] + 1):
            for z in range(vertical_bounds[0], vertical_bounds[1] + 1):
                if lattice[x][y][z] == lattice[int(width / 2) + x][y][z]:
                    symmetry_count += 1
    return symmetry_count

def depth_symmetry(lattice, horizontal_bounds, vertical_bounds, depth_bounds):
    symmetry_count = 0
    depth = depth_bounds[1] - depth_bounds[0]
    for x in range(horizontal_bounds[0], horizontal_bounds[1] + 1):
        for y in range(depth_bounds[0], int(depth_bounds[1] / 2) + 1):
            for z in range(vertical_bounds[0], vertical_bounds[1] + 1):
                if lattice[x][y][z] == lattice[x][int(depth / 2) + y][z]:
                    symmetry_count += 1
    return symmetry_count

def assess_quality(lattice):
    """
    :param lattice:
    :return:
    """
    interior_count = 0
    roof_count = 0
    surfaces = 0
    floor_count = 0
    total_count = 0

    horizontal_bounds, depth_bounds, vertical_bounds = bounding_box(lattice)
    footprint_ratios(lattice, horizontal_bounds, vertical_bounds, depth_bounds)
    bounding_box_volume = (horizontal_bounds[1] - horizontal_bounds[0]) * (depth_bounds[1] - depth_bounds[0]) * vertical_bounds[1]
    vertical_symmetry_count = height_symmetry(lattice, horizontal_bounds, vertical_bounds, depth_bounds)
    horizontal_symmetry_count = width_symmetry(lattice, horizontal_bounds, vertical_bounds, depth_bounds)
    depth_symmetry_count = depth_symmetry(lattice, horizontal_bounds, vertical_bounds, depth_bounds)

    for (x, y, z) in value_range:
        if lattice[x][y][z] > 0:
            total_count += 1
            if lattice[x][y][z] != 1:
                surfaces += 1
            if lattice[x][y][z] == 4:
                roof_count += 1
            elif lattice[x][y][z] == 3:
                floor_count += 1
            elif lattice[x][y][z] == 1:
                interior_count += 1

    try:
        surface_area_ratio = surfaces / lattice_dimensions[0] ** 3
        interior_ratio = interior_count / total_count
        floor_to_ceiling = floor_count / roof_count
        """if surface_area_ratio < 0.25 or interior_ratio < 0.5:
            raise InfeasibleError"""
    except ZeroDivisionError:
        raise InfeasibleError

    return [interior_ratio, floor_to_ceiling, surface_area_ratio]

def iterative_flood(input_lattice):
    """
    Given an input lattice perform an exhaustive flood-fill algorithm from the bottom of the
    XY plane to identify any floating voxels detached from the building inside lattice.
    Also detects separate structures and labels them accordingly.
    :param input_lattice: original lattice generated by CPPN-NEAT genome.
    :return: original lattice with floating voxels removed.
    """
    if np.sum(input_lattice) == 0 or np.sum(input_lattice) == lattice_dimensions[0] ** 3:
        raise InfeasibleError

    # Create a boolean grid using the same shape as the input lattice.
    visited = np.zeros(input_lattice.shape, int)
    label = 0

    # Create a set of all the voxels on the XY plane where Z = 0.
    for i in range(0, visited.shape[0]):
        for j in range(0, visited.shape[1]):
            if visited[i][j][0] == 0 and input_lattice[i][j][0] == 1:
                label += 1
                visited = detect_structure(input_lattice, visited, label, (i, j, 0))

    visited = keep_largest_structure(visited, label)
    if label == 0:
        raise InfeasibleError

    return visited

def detect_structure(lattice, visited, label, coordinate):
    """
    :param lattice:
    :param visited:
    :param label:
    :param coordinate:
    :return:
    """
    to_fill = set()
    to_fill.add(coordinate)

    # Keep looping whilst the set of remaining unvisited voxels is empty.
    while len(to_fill) != 0:

        # Pop the first element in the to-fill list.
        voxel = to_fill.pop()

        # If the voxel is active, mark it as true in the boolean grid and add it's neighbors
        if lattice[voxel[0]][voxel[1]][voxel[2]] != 0:
            visited[voxel[0]][voxel[1]][voxel[2]] = label
            if voxel[0] < 19 and not visited[voxel[0] + 1][voxel[1]][voxel[2]]:
                to_fill.add((voxel[0] + 1, voxel[1], voxel[2]))
            if voxel[0] > 0 and not visited[voxel[0] - 1][voxel[1]][voxel[2]]:
                to_fill.add((voxel[0] - 1, voxel[1], voxel[2]))
            if voxel[1] < 19 and not visited[voxel[0]][voxel[1] + 1][voxel[2]]:
                to_fill.add((voxel[0], voxel[1] + 1, voxel[2]))
            if voxel[1] > 0 and not visited[voxel[0]][voxel[1] - 1][voxel[2]]:
                to_fill.add((voxel[0], voxel[1] - 1, voxel[2]))
            if voxel[2] < 19 and not visited[voxel[0]][voxel[1]][voxel[2] + 1]:
                to_fill.add((voxel[0], voxel[1], voxel[2] + 1))
            if voxel[2] > 0 and not visited[voxel[0]][voxel[1]][voxel[2] - 1]:
                to_fill.add((voxel[0], voxel[1], voxel[2] - 1))

    # Return the boolean grid but converted to integer values to align with the rest of the pipeline
    return np.asarray(visited, dtype=int)

def keep_largest_structure(visited, label):
    """
    :param visited:
    :param label:
    :return:
    """
    if label == 0:
        return visited

    # number_of_voxels contains the number of each of the labeled voxels
    number_of_voxels = np.zeros(label, int)

    for i in range(0, number_of_voxels.shape[0]):
        number_of_voxels[i] = np.count_nonzero(visited == i + 1)

    # keeps the pointer of the max voxels from the array number_of_voxels
    most_voxels = np.where(number_of_voxels == np.amax(number_of_voxels))

    # the label that has the most voxels in the visited matrix
    keep_voxel = most_voxels[0][0] + 1

    # set the rest of the voxels to 0 and the keep_voxel elements to 1
    for i in range(0, visited.shape[0]):
        for j in range(0, visited.shape[1]):
            for k in range(0, visited.shape[2]):
                if visited[i][j][k] != 0 and not visited[i][j][k] == keep_voxel:

                    visited[i][j][k] = 0
                elif visited[i][j][k] != 0 and visited[i][j][k] == keep_voxel:
                    visited[i][j][k] = 1

    return visited

def identify_materials(lattice):
    """

    :param lattice:
    :return:
    """
    for x, y, z in value_range:
        if lattice[x][y][z] != 0:

            if z == 0:
                if lattice[x][y][z + 1] == 0:
                    lattice[x][y][z] = 0
                else:
                    lattice[x][y][z] = materials['Floor']
                continue
            elif z == lattice_dimensions[0] - 1:
                lattice[x][y][z] = materials['Roof']
                continue
            else:
                if lattice[x][y][z + 1] == 0:
                    lattice[x][y][z] = materials['Roof']
                    continue

                if lattice[x][y][z - 1] == 0:
                    if lattice[x][y][z + 1] == 0:
                        lattice[x][y][z] = 0
                    else:
                        lattice[x][y][z] = materials['Floor']

            if x == 0 or y == 0:
                lattice[x][y][z] = materials['Wall']
            try:
                if lattice[x + 1][y][z] == 0:
                    lattice[x][y][z] = materials['Wall']
                elif lattice[x - 1][y][z] == 0:
                    lattice[x][y][z] = materials['Wall']
                elif lattice[x][y + 1][z] == 0:
                    lattice[x][y][z] = materials['Wall']
                elif lattice[x][y - 1][z] == 0:
                    lattice[x][y][z] = materials['Wall']
            except IndexError:
                lattice[x][y][z] = materials['Wall']

    return lattice

def change_to_ones(input_lattice):
    """

    :param input_lattice: 
    :return: 
    """
    for i in range(0, input_lattice.shape[0]):
        for j in range(0, input_lattice.shape[1]):
            for k in range(0, input_lattice.shape[2]):
                """# Set interior space to empty voxels
                if input_lattice[i][j][k] == 1:
                    input_lattice[i][j][k] = 0"""
                if input_lattice[i][j][k] != 0:
                    input_lattice[i][j][k] = 1
