from multiprocessing import Pool
from Delenox_Config import lattice_dimensions, thread_count, value_range
import numpy as np

from Visualization import visualize


def apply_constraints_parallel(input_lattices):
    """
    :param input_lattices:
    :return:
    """
    pool = Pool(thread_count)
    jobs = []
    noisy_lattices = []
    for lattice in input_lattices:
        jobs.append(pool.apply_async(apply_constraints, (lattice, )))
    for job in jobs:
        noisy_lattices.append(job.get()[1])
    pool.close()
    pool.join()
    return noisy_lattices


def apply_constraints(lattice):
    """
    Take the lattice generated by a CPPN-NEAT genome and apply the set of constraints implemented in
    the pipeline.
    :param lattice: Input lattice generated by CPPN-NEAT genome.
    :return: Adjusted lattice resulting from constraint functions.
    """
    valid = False
    metrics = []
    if np.sum(lattice) != 0 and np.sum(lattice) != lattice_dimensions[0] ** 3:
        valid, lattice = repair_lattice(lattice)
        if valid:
            (valid, metrics), lattice = analyse_lattice(lattice)
        # change_to_ones(lattice)
    return valid, lattice, metrics


def repair_lattice(lattice):
    """
    :param lattice:
    :return:
    """
    lattice, valid = iterative_flood(lattice)
    # lattice = call_edge_detect(lattice)
    return valid, lattice


def analyse_lattice(lattice):
    """
    :param lattice:
    :return:
    """
    lattice = new_edge_detect(lattice)
    lattice = locate_ceiling(lattice)
    lattice = locate_floor(lattice)
    return check_constraints(lattice), lattice


def check_constraints(lattice):
    """
    :param lattice:
    :return:
    """
    interior_count = 0
    roof_count = 0
    total_count = 0
    floor_count = 0

    for (x, y, z) in value_range:
        if lattice[x][y][z] > 0:
            total_count += 1
            if lattice[x][y][z] == 4:
                roof_count += 1
            elif lattice[x][y][z] == 3:
                floor_count += 1
            elif lattice[x][y][z] == 1:
                interior_count += 1

    total_voxel_ratio = total_count / lattice_dimensions[0] ** 3
    interior_ratio = interior_count / total_count

    try:
        floor_to_ceiling = floor_count / roof_count
    except ZeroDivisionError:
        floor_to_ceiling = np.nan

    return True, [interior_ratio, floor_to_ceiling, total_voxel_ratio]


def iterative_flood(input_lattice):
    """
    Given an input lattice perform an exhaustive flood-fill algorithm from the bottom of the
    XY plane to identify any floating voxels detached from the building inside lattice.
    Also detects separate structures and labels them accordingly.
    :param input_lattice: original lattice generated by CPPN-NEAT genome.
    :return: original lattice with floating voxels removed.
    """
    # Create a boolean grid using the same shape as the input lattice.
    visited = np.zeros(input_lattice.shape, int)
    label = 0

    # Create a set of all the voxels on the XY plane where Z = 0.
    for i in range(0, visited.shape[0]):
        for j in range(0, visited.shape[1]):
            if visited[i][j][0] == 0 and input_lattice[i][j][0] == 1:
                label += 1
                visited = detect_structure(input_lattice, visited, label, (i, j, 0))

    visited = keep_largest_structure(visited, label)
    return visited, label != 0


def detect_structure(lattice, visited, label, coordinate):
    """
    :param lattice:
    :param visited:
    :param label:
    :param coordinate:
    :return:
    """
    to_fill = set()
    to_fill.add(coordinate)

    # Keep looping whilst the set of remaining unvisited voxels is empty.
    while len(to_fill) != 0:

        # Pop the first element in the to-fill list.
        voxel = to_fill.pop()

        # If the voxel is active, mark it as true in the boolean grid and add it's neighbors
        if lattice[voxel[0]][voxel[1]][voxel[2]] != 0:
            visited[voxel[0]][voxel[1]][voxel[2]] = label
            if voxel[0] < 19 and not visited[voxel[0] + 1][voxel[1]][voxel[2]]:
                to_fill.add((voxel[0] + 1, voxel[1], voxel[2]))
            if voxel[0] > 0 and not visited[voxel[0] - 1][voxel[1]][voxel[2]]:
                to_fill.add((voxel[0] - 1, voxel[1], voxel[2]))
            if voxel[1] < 19 and not visited[voxel[0]][voxel[1] + 1][voxel[2]]:
                to_fill.add((voxel[0], voxel[1] + 1, voxel[2]))
            if voxel[1] > 0 and not visited[voxel[0]][voxel[1] - 1][voxel[2]]:
                to_fill.add((voxel[0], voxel[1] - 1, voxel[2]))
            if voxel[2] < 19 and not visited[voxel[0]][voxel[1]][voxel[2] + 1]:
                to_fill.add((voxel[0], voxel[1], voxel[2] + 1))
            if voxel[2] > 0 and not visited[voxel[0]][voxel[1]][voxel[2] - 1]:
                to_fill.add((voxel[0], voxel[1], voxel[2] - 1))

    # Return the boolean grid but converted to integer values to align with the rest of the pipeline
    return np.asarray(visited, dtype=int)


def keep_largest_structure(visited, label):
    """
    :param visited:
    :param label:
    :return:
    """
    if label == 0:
        return visited

    # number_of_voxels contains the number of each of the labeled voxels
    number_of_voxels = np.zeros(label, int)

    for i in range(0, number_of_voxels.shape[0]):
        number_of_voxels[i] = np.count_nonzero(visited == i + 1)

    # keeps the pointer of the max voxels from the array number_of_voxels
    most_voxels = np.where(number_of_voxels == np.amax(number_of_voxels))

    # the label that has the most voxels in the visited matrix
    keep_voxel = most_voxels[0][0] + 1

    # set the rest of the voxels to 0 and the keep_voxel elements to 1
    for i in range(0, visited.shape[0]):
        for j in range(0, visited.shape[1]):
            for k in range(0, visited.shape[2]):
                if visited[i][j][k] != 0 and not visited[i][j][k] == keep_voxel:

                    visited[i][j][k] = 0
                elif visited[i][j][k] != 0 and visited[i][j][k] == keep_voxel:
                    visited[i][j][k] = 1

    return visited


def locate_floor(input_lattice):
    """
    Filter to locate the floor plan of a given lattice, where any voxel is enabled on the XY plane (Z = 0).
    :param input_lattice: input lattice with floating voxels removed.
    :return: Adjusted lattice with floor plan voxel ID's set to 3.
    """
    for x in range(0, input_lattice.shape[0]):
        for y in range(0, input_lattice.shape[1]):
            if input_lattice[x][y][0] != 0:
                input_lattice[x][y][0] = 3
    return input_lattice


def locate_ceiling(input_lattice):
    """

    :param input_lattice:
    :return:
    """
    for i in range(0, input_lattice.shape[0]):
        for j in range(0, input_lattice.shape[1]):
            for k in range(input_lattice.shape[2]-1, -1, -1):
                if input_lattice[i][j][k] != 0:
                    input_lattice[i][j][k] = 4
                    break
    return input_lattice


def new_edge_detect(lattice):
    """

    :param lattice:
    :return:
    """
    for x, y, z in value_range:
        if lattice[x][y][z] == 1:

            if x == 0 or y == 0 or z == 0:
                lattice[x][y][z] = 2
                continue

            try:
                if lattice[x + 1][y][z] == 0:
                    lattice[x][y][z] = 2
                elif lattice[x - 1][y][z] == 0:
                    lattice[x][y][z] = 2
                elif lattice[x][y + 1][z] == 0:
                    lattice[x][y][z] = 2
                elif lattice[x][y - 1][z] == 0:
                    lattice[x][y][z] = 2
                elif lattice[x][y][z + 1] == 0:
                    lattice[x][y][z] = 2
                elif lattice[x][y][z - 1] == 0:
                    lattice[x][y][z] = 2
            except IndexError:
                lattice[x][y][z] = 2

    return lattice


def call_cal_com(input_lattice):
    """

    :param input_lattice:
    :return:
    """
    array_cx = np.zeros(input_lattice.shape[0])
    array_cy = np.zeros(input_lattice.shape[0])
    for i in range(0, input_lattice.shape[0]):
        array_cx[i], array_cy[i] = calc_com(input_lattice[:, :, i])
    cx_avg = np.sum(array_cx) / len(array_cx)
    cy_avg = np.sum(array_cy) / len(array_cy)
    return round(cx_avg, 2), round(cy_avg, 2)


def calc_com(input_slice):
    """

    :param input_slice:
    :return:
    """
    input_slice = np.array(input_slice)
    cx = np.zeros_like(input_slice)
    cy = np.zeros_like(input_slice)
    for i in range(0, cx.shape[0]):
        for j in range(0, cx.shape[1]):
            if j < cx.shape[0] / 2:
                cx[i][j] = input_slice[i][j] * (j - 10)
            else:
                cx[i][j] = input_slice[i][j] * (j - 9)
            if i < cx.shape[0] / 2:
                cy[i][j] = input_slice[i][j] * (i - 10)
            else:
                cy[i][j] = input_slice[i][j] * (i - 9)

    centerOfMassX = np.sum(cx) / np.count_nonzero(cx)
    centerOfMassY = np.sum(cy) / np.count_nonzero(cy)

    return centerOfMassX, centerOfMassY


def call_calc_point_symmetry(input_lattice):
    """

    :param input_lattice:
    :return:
    """
    symmetrySum = 0

    for i in range(0, input_lattice.shape[0]):
        symmetrySum += calc_point_symmetry(input_lattice[:, :, i])

    return round(symmetrySum / input_lattice.shape[0], 2)


def calc_point_symmetry(input_slice):
    """

    :param input_slice:
    :return:
    """
    input_slice = np.array(input_slice)
    numberOfTiles = np.count_nonzero(input_slice)
    numberOfMirroredTiles = 0

    if numberOfTiles == 0:
        return 0

    halfCol = int(input_slice.shape[1] / 2)

    for i in range(0, input_slice.shape[0]):
        for j in range(0, halfCol):
            if input_slice[i][j] != 0:
                if input_slice[i][j] == input_slice[input_slice.shape[0] - 1 - i][input_slice.shape[0] - 1 - j]:
                    numberOfMirroredTiles += 1

    return numberOfMirroredTiles / numberOfTiles


def change_to_ones(input_lattice):
    """

    :param input_lattice: 
    :return: 
    """
    for i in range(0, input_lattice.shape[0]):
        for j in range(0, input_lattice.shape[1]):
            for k in range(0, input_lattice.shape[2]):
                if input_lattice[i][j][k] == 1:
                    input_lattice[i][j][k] = 0
                elif input_lattice[i][j][k] != 0:
                    input_lattice[i][j][k] = 1
