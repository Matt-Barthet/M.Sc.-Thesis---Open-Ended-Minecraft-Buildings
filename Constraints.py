from scipy.ndimage import center_of_mass
from Delenox_Config import lattice_dimensions, value_range
import numpy as np
from Visualization import voxel_plot
from scipy.spatial import distance

materials = {'External_Space': 0, 'Interior_Space': 1, 'Wall': 2, 'Floor': 3, 'Roof': 4}


class InfeasibleError(Exception):
    pass


def apply_constraints(lattice):
    """
    Take the lattice generated by a CPPN-NEAT genome and apply the set of constraints implemented in
    the pipeline.
    :param lattice: Input lattice generated by CPPN-NEAT genome.
    :return: Adjusted lattice resulting from constraint functions.
    """
    try:
        lattice = iterative_flood(lattice)
        lattice = identify_materials(lattice)
        metrics = assess_quality(lattice)
        return True, lattice, metrics
    except InfeasibleError:
        return False, lattice, []


def bounding_box(lattice):
    """
    :param lattice:
    returns:
    """
    left_bound = 20
    right_bound = 0
    near_bound = 20
    far_bound = 0
    bottom_bound = 0
    top_bound = 0
    for (x, y, z) in value_range:
        if lattice[x][y][z] > 1:
            if y > far_bound:
                far_bound = y
            elif y < near_bound:
                near_bound = y
            if x > right_bound:
                right_bound = x
            elif x < left_bound:
                left_bound = x
            if z > top_bound:
                top_bound = z
    return (left_bound, right_bound), (near_bound, far_bound), (bottom_bound, top_bound)


def footprint_ratios(lattice, horizontal_bounds, vertical_bounds, depth_bounds):
    top_half = 1
    bottom_half = 1
    left_half = 1
    right_half = 1
    near_half = 1
    far_half = 1
    middle_x = 1
    outside_x = 1
    middle_y = 1
    outside_y = 1
    middle_z = 1
    outside_z = 1

    width = horizontal_bounds[1] - horizontal_bounds[0]
    depth = depth_bounds[1] - depth_bounds[0]
    height = vertical_bounds[1]

    for x in range(horizontal_bounds[0], horizontal_bounds[1] + 1):
        for y in range(depth_bounds[0], depth_bounds[1] + 1):
            for z in range(vertical_bounds[0], vertical_bounds[1] + 1):
                if lattice[x][y][z] > 1:
                    if horizontal_bounds[0] + width / 4 < x < horizontal_bounds[1] - width / 4:
                        middle_x += 1
                    else:
                        outside_x += 1
                    if depth_bounds[0] + depth / 4 < y < depth_bounds[1] - depth / 4:
                        middle_y += 1
                    else:
                        outside_y += 1
                    if height / 4 < z < vertical_bounds[1] - height / 4:
                        middle_z += 1
                    else:
                        outside_z += 1
                    if x < horizontal_bounds[0] + width / 2:
                        left_half += 1
                    else:
                        right_half += 1
                    if y < depth_bounds[0] + depth / 2:
                        bottom_half += 1
                    else:
                        top_half += 1
                    if z < height / 2:
                        near_half += 1
                    else:
                        far_half += 1

    horizontal_footprint = left_half/right_half
    depth_footprint = near_half/far_half
    vertical_footprint = top_half/bottom_half
    horizontal_middle = middle_x/outside_x
    depth_middle = middle_y/outside_y
    vertical_middle = middle_z/outside_z

    return [horizontal_footprint, depth_footprint, vertical_footprint, horizontal_middle, depth_middle, vertical_middle]


def height_symmetry(lattice, horizontal_bounds, vertical_bounds, depth_bounds):
    symmetry_count = 0
    for x in range(horizontal_bounds[0], horizontal_bounds[1] + 1):
        for y in range(depth_bounds[0], depth_bounds[1] + 1):
            for z in range(vertical_bounds[0], int(vertical_bounds[1] / 2) + 1):
                if lattice[x][y][z] > 1 and lattice[x][y][int(vertical_bounds[1] / 2) + z] > 1:
                    symmetry_count += 1
    return symmetry_count


def width_symmetry(lattice, horizontal_bounds, vertical_bounds, depth_bounds):
    symmetry_count = 0
    width = horizontal_bounds[1] - horizontal_bounds[0]
    for x in range(horizontal_bounds[0], int(horizontal_bounds[1] / 2) + 1):
        for y in range(depth_bounds[0], depth_bounds[1] + 1):
            for z in range(vertical_bounds[0], vertical_bounds[1] + 1):
                if lattice[x][y][z] == lattice[int(width / 2) + x][y][z]:
                    symmetry_count += 1
    return symmetry_count


def depth_symmetry(lattice, horizontal_bounds, vertical_bounds, depth_bounds):
    symmetry_count = 0
    depth = depth_bounds[1] - depth_bounds[0]
    for x in range(horizontal_bounds[0], horizontal_bounds[1] + 1):
        for y in range(depth_bounds[0], int(depth_bounds[1] / 2) + 1):
            for z in range(vertical_bounds[0], vertical_bounds[1] + 1):
                if lattice[x][y][z] == lattice[x][int(depth / 2) + y][z]:
                    symmetry_count += 1
    return symmetry_count


def stability(lattice):
    try:
        boolean_lattice = change_to_ones(lattice.copy())
        lattice_com = center_of_mass(boolean_lattice)
        floor_plan = np.zeros((lattice_dimensions[0], lattice_dimensions[1]))
        for i in range(0, lattice.shape[0]):
            for j in range(0, lattice.shape[1]):
                if lattice[i][j][0] == 3:
                    floor_plan[i][j] = 1
        (floor_x, floor_y) = center_of_mass(floor_plan)
        return distance.euclidean((floor_x, floor_y, 0), lattice_com), distance.euclidean((floor_x, floor_y), (lattice_com[0], lattice_com[1]))
    except (ValueError, RuntimeError):
        raise InfeasibleError


def assess_quality(lattice):
    """
    :param lattice:
    :return:
    """
    interior_count = 0
    roof_count = 0
    walls = 0
    floor_count = 0
    total_count = 0

    horizontal_bounds, depth_bounds, vertical_bounds = bounding_box(lattice)
    (horizontal_footprint, depth_footprint, vertical_footprint, horizontal_middle, depth_middle, vertical_middle) = footprint_ratios(lattice, horizontal_bounds, vertical_bounds, depth_bounds)

    width = (horizontal_bounds[1] - horizontal_bounds[0])
    height = vertical_bounds[1]
    depth = (depth_bounds[1] - depth_bounds[0])

    bounding_box_volume = width * depth * height
    bounding_box_area = (width * depth + width * height + height * depth) * 2

    """vertical_symmetry_count = height_symmetry(lattice, horizontal_bounds, vertical_bounds, depth_bounds)
    horizontal_symmetry_count = width_symmetry(lattice, horizontal_bounds, vertical_bounds, depth_bounds)
    depth_symmetry_count = depth_symmetry(lattice, horizontal_bounds, vertical_bounds, depth_bounds)"""
    lattice_stability, floor_stability = stability(lattice)

    for (x, y, z) in value_range:
        if lattice[x][y][z] > 0:
            total_count += 1
            if lattice[x][y][z] == 2:
                walls += 1
            elif lattice[x][y][z] == 4:
                roof_count += 1
            elif lattice[x][y][z] == 3:
                floor_count += 1
            elif lattice[x][y][z] == 1:
                interior_count += 1
    try:
        building_bounding_area = (walls + roof_count + floor_count) / bounding_box_area
        building_bounding_volume = total_count / bounding_box_volume
        bounding_lattice_volume = bounding_box_volume / lattice_dimensions[0] ** 3
        interior_volume = interior_count / lattice_dimensions[0] ** 3

        """if 0 < horizontal_middle <= 0.25:
            voxel_plot(lattice, " 0.25 : 1 (X-Plane - Middle Voxels : Outer Voxels)")
        elif 0.25 < horizontal_middle <= 0.5:
            voxel_plot(lattice, " 0.5 : 1 (X-Plane - Middle Voxels : Outer Voxels)")
        elif 0.5 < horizontal_middle <= 0.75:
            voxel_plot(lattice, " 0.75 : 1 (X-Plane - Middle Voxels : Outer Voxels)")
        elif 0.75 < horizontal_middle <= 1:
            voxel_plot(lattice, " 1 : 1 (X-Plane - Middle Voxels : Outer Voxels)")
        elif 1 < horizontal_middle <= 1.25:
            voxel_plot(lattice, " 1.25 : 1 (X-Plane - Middle Voxels : Outer Voxels)")
        elif 1.25 < horizontal_middle <= 1.5:
            voxel_plot(lattice, " 1.5 : 1 (X-Plane - Middle Voxels : Outer Voxels)")
        elif 1.5 < horizontal_middle <= 1.75:
            voxel_plot(lattice, " 1.75 : 1 (X-Plane - Middle Voxels : Outer Voxels)")
        elif 1.75 < horizontal_middle <= 2:
            voxel_plot(lattice, " 2 : 1 (X-Plane - Middle Voxels : Outer Voxels)")"""

        """if building_bounding_area < 0.7 or (interior_volume < 0.2 or interior_volume > 0.6) or floor_stability > 4:
            raise InfeasibleError"""

        return {"Building Area": building_bounding_area, "Building Volume": building_bounding_volume,
                "Bounding Box Volume": bounding_lattice_volume, "Lattice Stability": lattice_stability,
                "Width Middle": horizontal_middle, "Depth Middle": depth_middle, "Interior Volume": interior_volume}

    except ZeroDivisionError:
        raise InfeasibleError


def iterative_flood(input_lattice):
    """
    Given an input lattice perform an exhaustive flood-fill algorithm from the bottom of the
    XY plane to identify any floating voxels detached from the building inside lattice.
    Also detects separate structures and labels them accordingly.
    :param input_lattice: original lattice generated by CPPN-NEAT genome.
    :return: original lattice with floating voxels removed.
    """
    if np.sum(input_lattice) == 0 or np.sum(input_lattice) == lattice_dimensions[0] ** 3:
        raise InfeasibleError

    # Create a boolean grid using the same shape as the input lattice.
    visited = np.zeros(input_lattice.shape, int)
    label = 0

    # Create a set of all the voxels on the XY plane where Z = 0.
    for i in range(0, visited.shape[0]):
        for j in range(0, visited.shape[1]):
            if visited[i][j][0] == 0 and input_lattice[i][j][0] == 1:
                label += 1
                visited = detect_structure(input_lattice, visited, label, (i, j, 0))

    visited = keep_largest_structure(visited, label)
    if label == 0:
        raise InfeasibleError

    return visited


def detect_structure(lattice, visited, label, coordinate):
    """
    :param lattice:
    :param visited:
    :param label:
    :param coordinate:
    :return:
    """
    to_fill = set()
    to_fill.add(coordinate)

    # Keep looping whilst the set of remaining unvisited voxels is empty.
    while len(to_fill) != 0:

        # Pop the first element in the to-fill list.
        voxel = to_fill.pop()

        # If the voxel is active, mark it as true in the boolean grid and add it's neighbors
        if lattice[voxel[0]][voxel[1]][voxel[2]] != 0:
            visited[voxel[0]][voxel[1]][voxel[2]] = label
            if voxel[0] < 19 and not visited[voxel[0] + 1][voxel[1]][voxel[2]]:
                to_fill.add((voxel[0] + 1, voxel[1], voxel[2]))
            if voxel[0] > 0 and not visited[voxel[0] - 1][voxel[1]][voxel[2]]:
                to_fill.add((voxel[0] - 1, voxel[1], voxel[2]))
            if voxel[1] < 19 and not visited[voxel[0]][voxel[1] + 1][voxel[2]]:
                to_fill.add((voxel[0], voxel[1] + 1, voxel[2]))
            if voxel[1] > 0 and not visited[voxel[0]][voxel[1] - 1][voxel[2]]:
                to_fill.add((voxel[0], voxel[1] - 1, voxel[2]))
            if voxel[2] < 19 and not visited[voxel[0]][voxel[1]][voxel[2] + 1]:
                to_fill.add((voxel[0], voxel[1], voxel[2] + 1))
            if voxel[2] > 0 and not visited[voxel[0]][voxel[1]][voxel[2] - 1]:
                to_fill.add((voxel[0], voxel[1], voxel[2] - 1))

    # Return the boolean grid but converted to integer values to align with the rest of the pipeline
    return np.asarray(visited, dtype=int)


def keep_largest_structure(visited, label):
    """
    :param visited:
    :param label:
    :return:
    """
    if label == 0:
        return visited

    # number_of_voxels contains the number of each of the labeled voxels
    number_of_voxels = np.zeros(label, int)

    for i in range(0, number_of_voxels.shape[0]):
        number_of_voxels[i] = np.count_nonzero(visited == i + 1)

    # keeps the pointer of the max voxels from the array number_of_voxels
    most_voxels = np.where(number_of_voxels == np.amax(number_of_voxels))

    # the label that has the most voxels in the visited matrix
    keep_voxel = most_voxels[0][0] + 1

    # set the rest of the voxels to 0 and the keep_voxel elements to 1
    for i in range(0, visited.shape[0]):
        for j in range(0, visited.shape[1]):
            for k in range(0, visited.shape[2]):
                if visited[i][j][k] != 0 and not visited[i][j][k] == keep_voxel:
                    visited[i][j][k] = 0
                elif visited[i][j][k] != 0 and visited[i][j][k] == keep_voxel:
                    visited[i][j][k] = 1

    return visited


def identify_materials(lattice):
    """

    :param lattice:
    :return:
    """
    for x, y, z in value_range:
        if lattice[x][y][z] != 0:

            if z == 0:
                if lattice[x][y][z + 1] == 0:
                    lattice[x][y][z] = 0
                else:
                    lattice[x][y][z] = materials['Floor']
                continue
            elif z == lattice_dimensions[0] - 1:
                lattice[x][y][z] = materials['Roof']
                continue
            else:
                if lattice[x][y][z + 1] == 0:
                    lattice[x][y][z] = materials['Roof']
                    continue

                if lattice[x][y][z - 1] == 0:
                    if lattice[x][y][z + 1] == 0:
                        lattice[x][y][z] = 0
                    else:
                        lattice[x][y][z] = materials['Floor']

            if x == 0 or y == 0:
                lattice[x][y][z] = materials['Wall']
            try:
                if lattice[x + 1][y][z] == 0:
                    lattice[x][y][z] = materials['Wall']
                elif lattice[x - 1][y][z] == 0:
                    lattice[x][y][z] = materials['Wall']
                elif lattice[x][y + 1][z] == 0:
                    lattice[x][y][z] = materials['Wall']
                elif lattice[x][y - 1][z] == 0:
                    lattice[x][y][z] = materials['Wall']
            except IndexError:
                lattice[x][y][z] = materials['Wall']

    return lattice


def change_to_ones(input_lattice, keep_interior=False):
    """

    :param input_lattice:
    :param keep_interior
    :return: 
    """
    for i in range(0, input_lattice.shape[0]):
        for j in range(0, input_lattice.shape[1]):
            for k in range(0, input_lattice.shape[2]):
                if input_lattice[i][j][k] > 1:
                    input_lattice[i][j][k] = 1
                elif not keep_interior:
                    input_lattice[i][j][k] = 0
    return input_lattice
